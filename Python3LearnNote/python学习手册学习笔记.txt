书籍：《Learning Python》 《Programmming Python》

# 字符串是序列，元祖、列表是序列
字符串方法：
    find eg: s.find('x') 它将返回一个传入字符串的偏移量，如果没有找到返回-1
    replace eg: s.replace('x')  全局查找和搜索字符串
    split()
    upper()
    isalpha()
    rstrip()
    字符串格式化
        notice: 返回的结果不会改变原始字符串，而是会创建一个新的字符串作为结果

    dir函数：返回对象的所有属性，以列表的形式

# 字典不是序列，是映射（mapping)，它们并不包含任何可靠的从左到右的顺序。


# 迭代器协议

# 使用 in 来判断 key 是否存在于字典中


# 动态类型
    在python中，类型实在运行过程中自动决定的，而不是通过代码声明。

    在python中从变量到对象的引用称作引用
        即：引用是一种关系，以内存中的指针实现。 一旦变量被使用（也就是说被引用），  python自动跟随这个变量到对象的连接。

            变量是一个系统表的元素，拥有指向对象的连接的空间
            对象是分配的一块内存，有足够的空间去表示它们所代表的值
            引用是自动形成的从变量到对象的指针

    # 对象的垃圾收集
        在python中，每当一个变量名被赋予了一个新的对象，之前的那个对象占用的空间就会被回收（如果它没有被其他的变量名或者对象引用的话），这种自动回收对象空间的技术叫做垃圾收集
            python如何实现的：它在每个对象中保持了一个计数器，计数器记录了当前指向该对象的引用的数目。一旦（并精确在同一时间）这个计数器被设置为0，这个对象的内存空间就会自动回收。
        在python中类型属于对象

    ## 共享引用
        多个变量名引用了同一个对象
            在python中变量总是一个指向对象的指针，而不是可改变的内存区域的标签


    ## 共享引用和相等
        两种方法检查是否相等
            ==操作符：测试两个被引用的对象是否有相同的值
            is操作符 如果两个变量名精确地指向同一个对象它会返回True

        使用切片来保证引用的对象不会被改变（如果之前引用的对象是一个列表类型）

# python字符串-一个有序的字符集合
    不可变序列
        字符串合并操作：'hello' + 'world'
        转义字符：

        字符串切片可以用作提取部分数据，分离前、后缀等场合
            list[:] --实现了完全的顶层的序列对象的拷贝（值相同，但是内存区域不同

        ## 去掉换行字符串的方法：line.rstrip()

        ## ''.join() :  将列表字符串连在一起，并用分隔符隔开。


# 列表和字典

    ## 列表
        1，任意对象的有序集合
        2，也是序列

    ## 字典

# 内置类型陷阱
    ## 赋值生成引用，而不是拷贝

# 赋值语句


# python装饰器


# 迭代器和解析
    for循环可以用于python中任何序列类型（包括列表、元组以及字符串）,实际上for循环可以用任何可迭代对象

    迭代器协议：有__next__方法的对象会前进到下一个结果，而在一些列结果的末尾时，则会引发StopIteration. 在python中任何这类对象都认为是可迭代的


    手动迭代：iter和next



# python网络编程
    ip地址：互联网上每个计算机的唯一标识
    ip协议负责把数据从一台计算机通过网络发送到另外一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去

    端口作用：IP地址 + 端口 唯一确定一个进程

    tcp协议：负责在两台计算机之间建立可靠连接保证数据包按照顺序到达。tcp协议会通过握手建立连接，然后对每个IP包编号，确保对方按照顺序收到，如果包丢掉了，就自动重发

# python作用域基础
    命名空间==作用域：也就是说，在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围

    由于变量名没有声明，python将一个变量名被赋值的地点关联为一个特定的命名空间；换句话说，在代码中给一个变量赋值的地方决定了这个变量将存在于
        哪个命名空间，也就是它可见的范围。

    函数定义了本地作用域，而模块定义的是全局作用域
        内嵌的模块是全局作用域

            全局作用域的作用范围仅限于单个文件
                全局：指一个文件顶层的变量名仅对于这个文件内部的代码而言是全局的

    每次对函数的调用都创建了一个新的本地作用域

    赋值的变量名除非声明为全局变量或或非本地变量，否则均为本地变量

        如果需要给一个在函数内部却位于模块文件顶层的变量名赋值，需要在函数内部通过global语句声明


# 内置作用域
    内置作用域仅仅是一个名为 __builtin__ 的内置模块，必须先引用才能使用

# global语句
    声明一个命名空间
        1，全局变量是位于模块文件内部的顶层的变量名
        2，全局变量如果是在函数内被赋值的话，必须经过声明
        3，全局变量名在函数的内部不经过声明也可以被引用


# 最小化文件间变量的修改
    重点：通过在每个文件的基础上分割变量，它们避免了跨文件的名称冲突

    文件通信解决办法：在文件间进行通信最好的办法就是通过调用函数，传递参数，然后得到其返回值
        最好使用accessor函数去 管理这种变化

# 访问全局变量的其他方法


def f1():
    # X = 88

    def f2():
        print(X)
    return f2

    注1 ：这个代码中，f2()函数的调用动作的运行是在f1运行后发生的，f2会记住了在f1中嵌套作用域中的x,尽管f1已经不处于激活状态

    ##  工厂函数
        这种行为（注1）有时也叫做闭合（closure)或者工厂函数-- 一个能够记住嵌套作用域的变量值的函数，尽管哪个作用域或许已经不存在了


# 嵌套作用域和lambda
    ## 嵌套函数作用：实现状态保持

    ## nonlocal语句： 意味着完全忽略本地作用域
        nonlocal语句允许在内存中保持可变状态的副本，并且解决了在类无法保证的情况下的简单的状态保持
        ### 使用前提：nonlocal名称必须已经在一个嵌套的def作用域中赋值过，否则会报错
        ### 声明了将要在一个嵌套的作用域中修改的名称
            nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def 之外的全局模块作用域


# 参数

    位置：从左至右进行匹配
    关键字参数： name=value
    默认参数：为没有传入值的参数定义参数值
    可变参数：收集任意多基于位置或关键字的参数
        函数能够使用特定的参数，它们是以字符*开头，收集任意多额外参数（这个特性常常叫做可变参数

    可变参数解包：
        传递任意多的基于位置或关键字的参数
            调用者能够再使用*语法去将参数集合打散，分成参数。这个"*"与在函数头部的*恰恰相反
                在函数头部它意味着收集任意多的参数，而在调用者中意味着传递任意多的参数

    1，函数调用中，参数必须以此顺序出现：任何位置参数，后面跟着任何关键字参数（name=value)和*sequence形式的组合，后面跟着**dict形式

    2，在函数头部，参数必须以此顺序出现：任何一般参数（name),紧跟着任何默认参数(name=value),如果有的话，后面是*name, 然后后面是**name


# python函数设计
    * 耦合性：  对于输入使用参数并且对于输出使用return语句
    *          只有在真正必要的情况下才使用全局变量
                不要改变可变类型的参数，除非调用者希望这样做


    递归函数
        直接或者间接地调用自身以进行循环地函数

           用递归求和

    匿名函数：lambda
        为什么使用lambda: 起到了一种函数速写的作用，允许在使用的代码内嵌入一个函数的定义


python模块
    import如何工作
        第一次倒入时会这么做（否则不会）
        1, 找到模块文件
            python使用了标准模块搜索路径来找出import语句所对应的模块文件

            模块搜索路径（sys.path)
                a, 程序的主目录
                    程序会首先在主目录搜索导入的文件
                b, pythonpath目录
                    跨目录导入设置
                c, 标准链接库目录
                d, 任何.pth文件的内容(如果有）



        2，编译成位码（需要时）
        3，执行模块的代码来创建其所定义的对象

    命名空间：变量名建立所在的场所

    模块文件顶层：也就是不在函数或者类的主体内

    模块的命名空间能够通过属性__dict__获取


    重载模块
        模块程序代码默认只对每个过程执行一次

        如果要强制使模块代码重新载入并重新运行，你得可以要求python这么做，也就是调用reload内置函数

        探索如何使用reload让系统变得更加动态
            - 导入只会模块在流程中第一次导入时，加载和执行该模块的代码，之后的导入只会使用已加载的模块对象，而不会重载或重新执行代码
            - reload函数会强制已加载的模块对象的代码重新载入并重新执行。

        reload基础：
            - reload是python的内置函数
            - 传给load的是已经存在的模块对象，而不是变量名
            -
    包导入
        - 包导入语句的路径中的每个目录内都必须有__init__.py这个文件，否则导入包会失败

        - 使用如： dir0\dir1\dir2\mod.py 以及 import dir1.dir2.md需要遵守以下规则
            - dir1和dir2中必须含有一个__init__.py文件
            - dir0是容器，不需要__init__.py文件；如果有的话也会被忽略
            - dir0必须列在模块搜索路径上（此目录必须是主目录）

        - 包的初始化
            - python首次导入某个目录时，会自动执行该目录下__init__.py文件的所有程序代码

        - 只有在跨目录进行导入时才需要模块搜索路径的设置


    高级模块
        - 在模块中隐藏数据
           - 把下划线 '_' 放在变量前面可以防止客户端使用from * 语句导入模块名时，把其中的那些变量名复制出去； from * 会把所有变量名复制出去
           - __all__ = [] : 使用此功能时，from *语句只会把列在__all__列表中的这些变量名复制出来



        __name__ 和 __main__

类和oop


python线程和进程
    - 进程
        计算机程序：只是存储在磁盘上的可执行二进制程序文件
        进程：一个执行中的程序

    - 线程
        同一个进程下执行，并共享上下文

        - 线程包括：开始、执行顺序、结束
            可以被抢占，和临时挂起
        - 一个进程中的各个线程与主线程共享同一片数据空间，因此相比于独立的进程而言，线程间的信息共享和通信更加容易

    - 全局解释器锁 （GIL)
    - python虚拟机(解释器主循环)
        - py文件周期：py文件 --> 字节码（.pyc） --> python解释器执行字节码文件

        - 对python虚拟机的访问是由全局解释器锁（GIL）控制的

        - Python 代码的执行是由 Python 虚拟机(又名解释器主循环)进行控制的

            - 主循环中同时只能有一个控制线程在执行；python解释器中可以运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行
            - GIL保证同时只有一个线程运行的

            - 多线程下python解释器如何执行
                1，设置GIL
                2, 切换一个线程去执行
                3，执行下面操作之一
                    * 指定数量的字节码
                    * 线程主动让出控制权（可以调用time.sleep(0)来完成
                4，把线程设置回睡眠状态（切换出线程
                5，解锁GIL
                6, 重复
    - 守护线程
        当主线程退出时，所有子线程都将终止，不管他们是否任在工作；所以需要引入守护进程

    - thread类
        name: 线程名
        ident: 线程表示符号
        daemon: 布尔标志，表示这个线程是否是守护线程

        线程实例化：实例化一个线程，需要又一个可调用的target，以及其参数args or kwargs

        start(): 开始执行该线程
        run(): 定义线程功能的方法
        join(timeout): 直至启动的线程终止之前一直挂起，除非给出了超时时间，否则会一直挂起
        getName(): 返回线程名
        setName(name): 设定线程名
        isAlivel/is_alive(): 布尔标志，表示这个线程是否还存活
        isDaemon(): 如果是守护线程, True; False

    - 创建多线程的方法
        - 创建Thread的实例，传递给它一个函数
        - 创建Thread的实例，传递它一个可调用的类实例
        - 派生Thread的子类，并创建子类的实例 (推荐）

    - python并发性适用
        - python多线程适用于io密集型应用，因为python虚拟机是单线程(GIL)的原因


    - 线程同步
        在多线程中，总会有一些特定的函数或者代码不希望(或者不应该)被多个线程执行，通常包括修改数据库、更新文件或者
        其他会产生竞态谈条件的类似情况

        - 锁
            两种状态：锁定和未锁定

            获得锁和释放锁


# 字符和字节
    - 字符
        - unicode字符
            世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号，因此打开一个文件就需要知道它的编码方式

            unicode: 将世界上所有的符号都纳入其中
                缺点：没有规定二进制码如何存储
                - 如何区分ascii和unicode码？
                    - utf-8

            ## utf-8
                - unicode的实现方式之一
                - 它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

                utf-8规则：
                    1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

                    2）对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

        - ascii码
            计算机内部信息表示体现为： 一个个二进制值  --> 每一个二进制位（bit)，有两种状态0\1 --> 8个二进制位可以组合256中状态： 字节(byte)
                一个字节一共可以用来表示256种状态，每一个状态对应一个符号，就是256个符号，从 000000 至 111111

            ascii码：美国制定的一套字符编码：规定了英语字符与二进制位的关系；一共规定了128个字符的编码；比如空格是 32（00100000）

        - 非ascii码
            英语用128个字符就够了，但是其他语言128个字符是不够的

    - 码位
        字符的标识；是0 ~  1114111的数字，在unicode标准中以4~6个十六进制数字表示，而且家前缀U+

    - 字节序列
        字符的具体表述取决于所用的编码

        编码：把码位转换成字节序列的过程
        解码：把字节序列转换成码位的过程


# python深浅拷贝
    浅拷贝：对象的元素指向之前的内存地址

# python异常
    - try/ except ： 捕捉由python或你引起的异常并恢复

    - try / finally : 无论异常是否发生，执行清理行为

    - raise ： 手动在代码中触发异常

    - with / as

    异常所做的事：