书籍：《Learning Python》 《Programmming Python》

# 字符串是序列，元祖、列表是序列
字符串方法：
    find eg: s.find('x') 它将返回一个传入字符串的偏移量，如果没有找到返回-1
    replace eg: s.replace('x')  全局查找和搜索字符串
    split()
    upper()
    isalpha()
    rstrip()
    字符串格式化
        notice: 返回的结果不会改变原始字符串，而是会创建一个新的字符串作为结果

    dir函数：返回对象的所有属性，以列表的形式

# 字典不是序列，是映射（mapping)，它们并不包含任何可靠的从左到右的顺序。


# 迭代器协议

# 使用 in 来判断 key 是否存在于字典中


# 动态类型
    在python中，类型实在运行过程中自动决定的，而不是通过代码声明。

    在python中从变量到对象的引用称作引用
        即：引用是一种关系，以内存中的指针实现。 一旦变量被使用（也就是说被引用），  python自动跟随这个变量到对象的连接。

            变量是一个系统表的元素，拥有指向对象的连接的空间
            对象是分配的一块内存，有足够的空间去表示它们所代表的值
            引用是自动形成的从变量到对象的指针

    # 对象的垃圾收集
        在python中，每当一个变量名被赋予了一个新的对象，之前的那个对象占用的空间就会被回收（如果它没有被其他的变量名或者对象引用的话），这种自动回收对象空间的技术叫做垃圾收集
            python如何实现的：它在每个对象中保持了一个计数器，计数器记录了当前指向该对象的引用的数目。一旦（并精确在同一时间）这个计数器被设置为0，这个对象的内存空间就会自动回收。
        在python中类型属于对象

    ## 共享引用
        多个变量名引用了同一个对象
            在python中变量总是一个指向对象的指针，而不是可改变的内存区域的标签


    ## 共享引用和相等
        两种方法检查是否相等
            ==操作符：测试两个被引用的对象是否有相同的值
            is操作符 如果两个变量名精确地指向同一个对象它会返回True

        使用切片来保证引用的对象不会被改变（如果之前引用的对象是一个列表类型）

# python字符串-一个有序的字符集合
    不可变序列
        字符串合并操作：'hello' + 'world'
        转义字符：

        字符串切片可以用作提取部分数据，分离前、后缀等场合
            list[:] --实现了完全的顶层的序列对象的拷贝（值相同，但是内存区域不同

        ## 去掉换行字符串的方法：line.rstrip()

        ## ''.join() :  将列表字符串连在一起，并用分隔符隔开。


# 列表和字典

    ## 列表
        1，任意对象的有序集合
        2，也是序列

    ## 字典

# 内置类型陷阱
    ## 赋值生成引用，而不是拷贝

# 赋值语句


# python装饰器


# 迭代器和解析
    for循环可以用于python中任何序列类型（包括列表、元组以及字符串）,实际上for循环可以用任何可迭代对象

    迭代器协议：有__next__方法的对象会前进到下一个结果，而在一些列结果的末尾时，则会引发StopIteration. 在python中任何这类对象都认为是可迭代的


    手动迭代：iter和next



# python网络编程
    ip地址：互联网上每个计算机的唯一标识
    ip协议负责把数据从一台计算机通过网络发送到另外一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去

    端口作用：IP地址 + 端口 唯一确定一个进程

    tcp协议：负责在两台计算机之间建立可靠连接保证数据包按照顺序到达。tcp协议会通过握手建立连接，然后对每个IP包编号，确保对方按照顺序收到，如果包丢掉了，就自动重发

# python作用域基础
    命名空间==作用域：也就是说，在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围

    由于变量名没有声明，python将一个变量名被赋值的地点关联为一个特定的命名空间；换句话说，在代码中给一个变量赋值的地方决定了这个变量将存在于
        哪个命名空间，也就是它可见的范围。

    函数定义了本地作用域，而模块定义的是全局作用域
        内嵌的模块是全局作用域

            全局作用域的作用范围仅限于单个文件
                全局：指一个文件顶层的变量名仅对于这个文件内部的代码而言是全局的

    每次对函数的调用都创建了一个新的本地作用域

    赋值的变量名除非声明为全局变量或或非本地变量，否则均为本地变量

        如果需要给一个在函数内部却位于模块文件顶层的变量名赋值，需要在函数内部通过global语句声明


# 内置作用域
    内置作用域仅仅是一个名为 __builtin__ 的内置模块，必须先引用才能使用

# global语句
    声明一个命名空间
        1，全局变量是位于模块文件内部的顶层的变量名
        2，全局变量如果是在函数内被赋值的话，必须经过声明
        3，全局变量名在函数的内部不经过声明也可以被引用


# 最小化文件间变量的修改
    重点：通过在每个文件的基础上分割变量，它们避免了跨文件的名称冲突

    文件通信解决办法：在文件间进行通信最好的办法就是通过调用函数，传递参数，然后得到其返回值
        最好使用accessor函数去 管理这种变化

# 访问全局变量的其他方法


def f1():
    # X = 88

    def f2():
        print(X)
    return f2

    注1 ：这个代码中，f2()函数的调用动作的运行是在f1运行后发生的，f2会记住了在f1中嵌套作用域中的x,尽管f1已经不处于激活状态

    ##  工厂函数
        这种行为（注1）有时也叫做闭合（closure)或者工厂函数-- 一个能够记住嵌套作用域的变量值的函数，尽管哪个作用域或许已经不存在了


# 嵌套作用域和lambda
    ## 嵌套函数作用：实现状态保持

    ## nonlocal语句： 意味着完全忽略本地作用域
        nonlocal语句允许在内存中保持可变状态的副本，并且解决了在类无法保证的情况下的简单的状态保持
        ### 使用前提：nonlocal名称必须已经在一个嵌套的def作用域中赋值过，否则会报错
        ### 声明了将要在一个嵌套的作用域中修改的名称
            nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def 之外的全局模块作用域


# 参数

    位置：从左至右进行匹配
    关键字参数： name=value
    默认参数：为没有传入值的参数定义参数值
    可变参数：收集任意多基于位置或关键字的参数
        函数能够使用特定的参数，它们是以字符*开头，收集任意多额外参数（这个特性常常叫做可变参数

    可变参数解包：
        传递任意多的基于位置或关键字的参数
            调用者能够再使用*语法去将参数集合打散，分成参数。这个"*"与在函数头部的*恰恰相反
                在函数头部它意味着收集任意多的参数，而在调用者中意味着传递任意多的参数

    1，函数调用中，参数必须以此顺序出现：任何位置参数，后面跟着任何关键字参数（name=value)和*sequence形式的组合，后面跟着**dict形式

    2，在函数头部，参数必须以此顺序出现：任何一般参数（name),紧跟着任何默认参数(name=value),如果有的话，后面是*name, 然后后面是**name


# python函数设计
    * 耦合性：  对于输入使用参数并且对于输出使用return语句
    *          只有在真正必要的情况下才使用全局变量
                不要改变可变类型的参数，除非调用者希望这样做


    递归函数
        直接或者间接地调用自身以进行循环地函数

           用递归求和

    匿名函数：lambda
        为什么使用lambda: 起到了一种函数速写的作用，允许在使用的代码内嵌入一个函数的定义


python模块
    import如何工作
        第一次倒入时会这么做（否则不会）
        1, 找到模块文件
            python使用了标准模块搜索路径来找出import语句所对应的模块文件

            模块搜索路径（sys.path)
                a, 程序的主目录
                    程序会首先在主目录搜索导入的文件
                b, pythonpath目录
                    跨目录导入设置
                c, 标准链接库目录
                d, 任何.pth文件的内容(如果有）



        2，编译成位码（需要时）
        3，执行模块的代码来创建其所定义的对象

    命名空间：变量名建立所在的场所

    模块文件顶层：也就是不在函数或者类的主体内

    模块的命名空间能够通过属性__dict__获取


    重载模块
        模块程序代码默认只对每个过程执行一次

        如果要强制使模块代码重新载入并重新运行，你得可以要求python这么做，也就是调用reload内置函数

        探索如何使用reload让系统变得更加动态
            - 导入只会模块在流程中第一次导入时，加载和执行该模块的代码，之后的导入只会使用已加载的模块对象，而不会重载或重新执行代码
            - reload函数会强制已加载的模块对象的代码重新载入并重新执行。

        reload基础：
            - reload是python的内置函数
            - 传给load的是已经存在的模块对象，而不是变量名
            -
    包导入
        - 包导入语句的路径中的每个目录内都必须有__init__.py这个文件，否则导入包会失败

        - 使用如： dir0\dir1\dir2\mod.py 以及 import dir1.dir2.md需要遵守以下规则
            - dir1和dir2中必须含有一个__init__.py文件
            - dir0是容器，不需要__init__.py文件；如果有的话也会被忽略
            - dir0必须列在模块搜索路径上（此目录必须是主目录）

        - 包的初始化
            - python首次导入某个目录时，会自动执行该目录下__init__.py文件的所有程序代码

        - 只有在跨目录进行导入时才需要模块搜索路径的设置


    高级模块
        - 在模块中隐藏数据
           - 把下划线 '_' 放在变量前面可以防止客户端使用from * 语句导入模块名时，把其中的那些变量名复制出去； from * 会把所有变量名复制出去
           - __all__ = [] : 使用此功能时，from *语句只会把列在__all__列表中的这些变量名复制出来



        __name__ 和 __main__
