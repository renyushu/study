书籍：《Learning Python》 《Programmming Python》

# 字符串是序列，元祖、列表是序列
字符串方法：
    find eg: s.find('x') 它将返回一个传入字符串的偏移量，如果没有找到返回-1
    replace eg: s.replace('x')  全局查找和搜索字符串
    split()
    upper()
    isalpha()
    rstrip()
    字符串格式化
        notice: 返回的结果不会改变原始字符串，而是会创建一个新的字符串作为结果

    dir函数：返回对象的所有属性，以列表的形式

# 字典不是序列，是映射（mapping)，它们并不包含任何可靠的从左到右的顺序。


# 迭代器协议

# 使用 in 来判断 key 是否存在于字典中


# 动态类型
    在python中，类型实在运行过程中自动决定的，而不是通过代码声明。

    在python中从变量到对象的引用称作引用
        即：引用是一种关系，以内存中的指针实现。 一旦变量被使用（也就是说被引用），  python自动跟随这个变量到对象的连接。

            变量是一个系统表的元素，拥有指向对象的连接的空间
            对象是分配的一块内存，有足够的空间去表示它们所代表的值
            引用是自动形成的从变量到对象的指针

    # 对象的垃圾收集
        在python中，每当一个变量名被赋予了一个新的对象，之前的那个对象占用的空间就会被回收（如果它没有被其他的变量名或者对象引用的话），这种自动回收对象空间的技术叫做垃圾收集
            python如何实现的：它在每个对象中保持了一个计数器，计数器记录了当前指向该对象的引用的数目。一旦（并精确在同一时间）这个计数器被设置为0，这个对象的内存空间就会自动回收。
        在python中类型属于对象

    ## 共享引用
        多个变量名引用了同一个对象
            在python中变量总是一个指向对象的指针，而不是可改变的内存区域的标签


    ## 共享引用和相等
        两种方法检查是否相等
            ==操作符：测试两个被引用的对象是否有相同的值
            is操作符 如果两个变量名精确地指向同一个对象它会返回True

        使用切片来保证引用的对象不会被改变（如果之前引用的对象是一个列表类型）

# python字符串-一个有序的字符集合
    不可变序列
        字符串合并操作：'hello' + 'world'
        转义字符：

        字符串切片可以用作提取部分数据，分离前、后缀等场合
            list[:] --实现了完全的顶层的序列对象的拷贝（值相同，但是内存区域不同

        ## 去掉换行字符串的方法：line.rstrip()

        ## ''.join() :  将列表字符串连在一起，并用分隔符隔开。


# 列表和字典

    ## 列表
        1，任意对象的有序集合
        2，也是序列

    ## 字典

# 内置类型陷阱
    ## 赋值生成引用，而不是拷贝

# 赋值语句


# python装饰器


# 迭代器和解析
    for循环可以用于python中任何序列类型（包括列表、元组以及字符串）,实际上for循环可以用任何可迭代对象

    迭代器协议：有__next__方法的对象会前进到下一个结果，而在一些列结果的末尾时，则会引发StopIteration. 在python中任何这类对象都认为是可迭代的


    手动迭代：iter和next



# python网络编程
    ip地址：互联网上每个计算机的唯一标识
    ip协议负责把数据从一台计算机通过网络发送到另外一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去

    端口作用：IP地址 + 端口 唯一确定一个进程

    tcp协议：负责在两台计算机之间建立可靠连接保证数据包按照顺序到达。tcp协议会通过握手建立连接，然后对每个IP包编号，确保对方按照顺序收到，如果包丢掉了，就自动重发

# python作用域基础
    命名空间==作用域：也就是说，在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围

    由于变量名没有声明，python将一个变量名被赋值的地点关联为一个特定的命名空间；换句话说，在代码中给一个变量赋值的地方决定了这个变量将存在于
        哪个命名空间，也就是它可见的范围。

    函数定义了本地作用域，而模块定义的是全局作用域
        内嵌的模块是全局作用域

            全局作用域的作用范围仅限于单个文件
                全局：指一个文件顶层的变量名仅对于这个文件内部的代码而言是全局的

    每次对函数的调用都创建了一个新的本地作用域

    赋值的变量名除非声明为全局变量或或非本地变量，否则均为本地变量

        如果需要给一个在函数内部却位于模块文件顶层的变量名赋值，需要在函数内部通过global语句声明


# 内置作用域
    内置作用域仅仅是一个名为 __builtin__ 的内置模块，必须先引用才能使用

# global语句
    声明一个命名空间
        1，全局变量是位于模块文件内部的顶层的变量名
        2，全局变量如果是在函数内被赋值的话，必须经过声明
        3，全局变量名在函数的内部不经过声明也可以被引用


# 最小化文件间变量的修改
    重点：通过在每个文件的基础上分割变量，它们避免了跨文件的名称冲突

    文件通信解决办法：在文件间进行通信最好的办法就是通过调用函数，传递参数，然后得到其返回值
        最好使用accessor函数去 管理这种变化

# 访问全局变量的其他方法


def f1():
    # X = 88

    def f2():
        print(X)
    return f2

    注1 ：这个代码中，f2()函数的调用动作的运行是在f1运行后发生的，f2会记住了在f1中嵌套作用域中的x,尽管f1已经不处于激活状态

    ##  工厂函数
        这种行为（注1）有时也叫做闭合（closure)或者工厂函数-- 一个能够记住嵌套作用域的变量值的函数，尽管哪个作用域或许已经不存在了


# 嵌套作用域和lambda
    ## 嵌套函数作用：实现状态保持

    ## nonlocal语句： 意味着完全忽略本地作用域
        nonlocal语句允许在内存中保持可变状态的副本，并且解决了在类无法保证的情况下的简单的状态保持
        ### 使用前提：nonlocal名称必须已经在一个嵌套的def作用域中赋值过，否则会报错
        ### 声明了将要在一个嵌套的作用域中修改的名称
            nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def 之外的全局模块作用域


# 参数






